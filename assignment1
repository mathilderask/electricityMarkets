# Example

using Pkg
Pkg.add("CSV")
Pkg.add("DataFrames")
Pkg.add("JuMP")
Pkg.add("GLPK")

using CSV, DataFrames, JuMP, GLPK

n = 12

# Read CSV files and specify column types to ensure Float64 conversion
df_GUD = CSV.read("GeneratingUnitsData.csv", DataFrame; types=Dict(:Pi_max => Float64, :Ci => Float64))
df_LP = CSV.read("LoadProfile.csv", DataFrame; types=Dict(Symbol("System_demand_(MW)") => Float64))
df_LN = CSV.read("LoadNodes.csv", DataFrame; types=Dict(:Percentage_SystemLoad => Float64))

# Extract data directly as Float64
Pi_max = df_GUD[!, :"Pi_max"]  # Maximum power output
Ci = df_GUD[!, :"Ci"]          # Production cost
Di = df_LP[!, "System_demand_(MW)"]  # Load profile
LN = df_LN[!, :"Percentage_SystemLoad"]  # Load node percentages
Dp = df_LN[!, :"U_d"]  # Demand price bids

# Compute the load for each node in only the first hour
D_FirstHour = [Di[1] * LN[i] for i in 1:length(LN)]

m = Model(GLPK.Optimizer)

# Add 6 windfarms of 200 MW each
i=1:length(Pi_max)
j=1:length(D_FirstHour)

@variable(m, P[i])
@variable(m, D[j])
# add variable for wind farms

@constraint(m, [k in i], 0 <= P[k] <= Pi_max[k])
@constraint(m, [k in j], 0 <= D[k] <= D_FirstHour[k])
@constraint(m, sum(D[k] for k in j) - sum(P[k] for k in i) == 0)

@objective(m, Max, sum(D[k] * Dp[k] for k in j) - sum(P[k] * Ci[k] for k in i))
#@objective(m, Min, sum(Ci[i] * P[i] for i = 1:n)) # Price * Production -- Market clearing price
optimize!(m)
if termination_status(m) == MOI.OPTIMAL
    println("Objective value: ", JuMP.objective_value(m))

# Extract and print optimal values for x1
    for i in keys(P)
        println("P[$i] = ", JuMP.value(P[i]))
    end

# Extract and print optimal values for x2
    for j in keys(D)
        println("D[$j] = ", JuMP.value(D[j]))
    end
else
    println("Optimize was not succesful. Return code: ", termination_status(m))
end

"""
# Define power production and unit commitment variables
@variable(m, GUD.Pi_min[i] <= p[i=1:num_units] <= GUD.Pi_max[i])  # Power output
@variable(m, u[i=1:num_units], Bin)  # Unit on/off status

# Initial conditions (optional, based on Pi_ini and Ui_ini)
@constraint(m, [i=1:num_units], p[i] >= GUD.Pi_min[i] * u[i])
@constraint(m, [i=1:num_units], p[i] <= GUD.Pi_max[i] * u[i])

# Ramp rate constraints
@constraint(m, ramp_up[i=1:num_units], p[i] - GUD.Pi_ini[i] <= GUD.Ri_+[i])
@constraint(m, ramp_down[i=1:num_units], GUD.Pi_ini[i] - p[i] <= GUD.Ri_-[i])

# Minimum up and down time constraints
@constraint(m, min_up_time[i=1:num_units], u[i] * GUD.UT[i] <= sum(u[j] for j in 1:num_units))
@constraint(m, min_down_time[i=1:num_units], (1 - u[i]) * GUD.DT[i] <= sum(1 - u[j] for j in 1:num_units))
"""

#@objective(m, Min, sum(Ci[i] * P[i] for i = 1:n)) # Price * Production -- Market clearing price

"""
optimize!(m)

if termination_status(m) == MOI.OPTIMAL
    println("Objective value: ", JuMP.objective_value(m))
    println("x1 = ", JuMP.value(x1))
    println("x2 = ", JuMP.value(x2))
else
    println("Optimize was not succesful. Return code: ", termination_status(m))
end
"""

